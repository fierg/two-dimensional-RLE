diff --git a/src/main/kotlin/edu/ba/twoDimensionalRLE/encoder/mixed/MixedEncoder.kt b/src/main/kotlin/edu/ba/twoDimensionalRLE/encoder/mixed/MixedEncoder.kt
index a5ec555..5d3c35d 100644
--- a/src/main/kotlin/edu/ba/twoDimensionalRLE/encoder/mixed/MixedEncoder.kt
+++ b/src/main/kotlin/edu/ba/twoDimensionalRLE/encoder/mixed/MixedEncoder.kt
@@ -101,8 +101,7 @@ class MixedEncoder : Encoder {
                 RLE_RANGE,
                 HUFF_BIT_RANGE,
                 huffDecoded.toByteArray(),
-                binRLE.decodeBinRleNumbersToBuffer(binRleNumbers, bitsPerRLENumber),
-                log
+                binRLE.decodeBinRleNumbersToBuffer(binRleNumbers, bitsPerRLENumber)
             )
 
             log.info("Applying reverted byte mapping to all chunks...")
diff --git a/src/main/kotlin/edu/ba/twoDimensionalRLE/model/DataChunk.kt b/src/main/kotlin/edu/ba/twoDimensionalRLE/model/DataChunk.kt
index 5fc970b..34d277f 100644
--- a/src/main/kotlin/edu/ba/twoDimensionalRLE/model/DataChunk.kt
+++ b/src/main/kotlin/edu/ba/twoDimensionalRLE/model/DataChunk.kt
@@ -3,13 +3,11 @@ package edu.ba.twoDimensionalRLE.model
 import de.jupf.staticlog.core.Logger
 import edu.ba.twoDimensionalRLE.extensions.isWholeNumber
 import edu.ba.twoDimensionalRLE.extensions.pow
-import edu.ba.twoDimensionalRLE.extensions.toBinStringBuffer
 import java.io.File
 import java.io.FileOutputStream
 import kotlin.experimental.and
 import kotlin.experimental.or
 import kotlin.math.ceil
-import kotlin.math.log
 
 @ExperimentalUnsignedTypes
 open class DataChunk(val input: ByteArray) {
@@ -61,41 +59,35 @@ open class DataChunk(val input: ByteArray) {
             rleRange: IntRange,
             huffRange: IntRange,
             huffDecodedBytes: ByteArray,
-            binRleBuffer: StringBuffer,
-            log: Logger
+            binRleBuffer: StringBuffer
         ): List<DataChunk> {
             val result = mutableListOf<DataChunk>()
             var currentChunk = DataChunk(ByteArray(0))
             var remainingSize = totalSize
-            val remainingBinRleBuffer = StringBuffer(binRleBuffer)
-            val remainingHuffmanBuffer = huffDecodedBytes.toBinStringBuffer()
-
-            try {
-                while (true) {
-                    val currentLength = if (remainingSize > byteArraySize) {
-                        remainingSize -= byteArraySize
-                        byteArraySize
-                    } else remainingSize
-
-                    //build bin rle decoded lines
-                    binRleRange.forEach { line ->
-                        currentChunk.decodedLinesStrBuffer[line] = remainingBinRleBuffer.substring(0, currentLength)
-                        remainingBinRleBuffer.delete(0, currentLength)
-                    }
-
-                    //huff decoded lines
-                    huffRange.forEach { line ->
-                        currentChunk.decodedLinesStrBuffer[line] = remainingHuffmanBuffer.substring(0, currentLength)
-                        remainingHuffmanBuffer.delete(0, currentLength)
-                    }
-                    result.add(currentChunk)
-                    currentChunk = DataChunk(ByteArray(0))
-                }
-            } catch (e: Exception) {
-                log.debug(e.localizedMessage, e)
+            var remainingBinRleBuffer = StringBuffer(binRleBuffer)
+            var remainingHuffmanBuffer = StringBuffer()
+            val huffBitBuffer = StringBuffer()
+            huffDecodedBytes.forEach { byte ->
+                huffBitBuffer.append(byte.toUByte().toInt().toString(2).padStart(8, '0'))
+            }
+
+            var currentLength = if (remainingSize > byteArraySize) {
+                remainingSize -= byteArraySize
+                byteArraySize
+            } else remainingSize
+
+
+            //build bin rle decoded lines
+            binRleRange.forEachIndexed { index, line ->
+                currentChunk.decodedLinesStrBuffer[line] = remainingBinRleBuffer.substring(0, currentLength)
+                remainingBinRleBuffer.delete(0, currentLength)
+            }
+
+            huffRange.forEach { line ->
+                currentChunk.decodedLinesStrBuffer[line]
             }
 
-            return result
+            TODO()
         }
 
     }
diff --git a/src/test/kotlin/edu/ba/twoDimensionalRLE/HuffmanTest.kt b/src/test/kotlin/edu/ba/twoDimensionalRLE/HuffmanTest.kt
index 15b19aa..2718d52 100644
--- a/src/test/kotlin/edu/ba/twoDimensionalRLE/HuffmanTest.kt
+++ b/src/test/kotlin/edu/ba/twoDimensionalRLE/HuffmanTest.kt
@@ -2,10 +2,12 @@ package edu.ba.twoDimensionalRLE
 
 import de.jupf.staticlog.Log
 import edu.ba.twoDimensionalRLE.encoder.huffman.HuffmanEncoder
+import edu.ba.twoDimensionalRLE.extensions.reversed
 import org.junit.jupiter.api.MethodOrderer
 import org.junit.jupiter.api.Order
 import org.junit.jupiter.api.Test
 import org.junit.jupiter.api.TestMethodOrder
+import java.io.File
 
 @TestMethodOrder(MethodOrderer.OrderAnnotation::class)
 class HuffmanTest {
@@ -25,6 +27,17 @@ class HuffmanTest {
         private const val inputString = "aaaabbbccddefg"
     }
 
+    @Test
+    @Order(1)
+    fun cleanup() {
+        if (File(encodeFolder).exists()) {
+            File(encodeFolder).deleteRecursively()
+            File(decodeFolder).deleteRecursively()
+        }
+        File(encodeFolder).mkdirs()
+        File(decodeFolder).mkdirs()
+    }
+
     @ExperimentalUnsignedTypes
     @Test
     @Order(2)
diff --git a/src/test/kotlin/edu/ba/twoDimensionalRLE/MixedEncoderCorpusTest.kt b/src/test/kotlin/edu/ba/twoDimensionalRLE/MixedEncoderCorpusTest.kt
index 28fcbb4..1ffd5e0 100644
--- a/src/test/kotlin/edu/ba/twoDimensionalRLE/MixedEncoderCorpusTest.kt
+++ b/src/test/kotlin/edu/ba/twoDimensionalRLE/MixedEncoderCorpusTest.kt
@@ -6,6 +6,7 @@ import org.junit.jupiter.api.MethodOrderer
 import org.junit.jupiter.api.Order
 import org.junit.jupiter.api.Test
 import org.junit.jupiter.api.TestMethodOrder
+import java.io.File
 
 @ExperimentalUnsignedTypes
 @ExperimentalStdlibApi
@@ -29,6 +30,21 @@ class MixedEncoderCorpusTest {
 
     private val mixedEncoder = MixedEncoder()
 
+    @Test
+    @Order(1)
+    fun cleanup() {
+        if (File("$encodeFolder/CalgaryCorpus").exists()) {
+            log.info("deleting directory: $encodeFolder/CalgaryCorpus")
+            File("$encodeFolder/CalgaryCorpus").deleteRecursively()
+            File("$decodeFolder/CalgaryCorpus").deleteRecursively()
+
+
+        }
+        log.info("creating directory: $encodeFolder/CalgaryCorpus")
+        File("$encodeFolder/CalgaryCorpus").mkdirs()
+        File("$decodeFolder/CalgaryCorpus").mkdirs()
+
+    }
 
     @Test
     @Order(2)
diff --git a/src/test/kotlin/edu/ba/twoDimensionalRLE/MixedEncoderTest.kt b/src/test/kotlin/edu/ba/twoDimensionalRLE/MixedEncoderTest.kt
index 07f73ec..15364f4 100644
--- a/src/test/kotlin/edu/ba/twoDimensionalRLE/MixedEncoderTest.kt
+++ b/src/test/kotlin/edu/ba/twoDimensionalRLE/MixedEncoderTest.kt
@@ -46,43 +46,30 @@ class MixedEncoderTest {
     @Test
     @Order(2)
     fun encodeFileSmall() {
-        encoder.encode(
-            "data/${fileToEncodeSmall}", "${encodeFolder}/${fileToEncodeSmall}",
+        encoder.encode("data/${fileToEncodeSmall}", "${encodeFolder}/${fileToEncodeSmall}",
             applyByteMapping = true,
-            applyBurrowsWheelerTransformation = true
-        )
+            applyBurrowsWheelerTransformation = true)
     }
-
     @Test
     @Order(7)
     fun decodeFileSmall() {
-        encoder.decode(
-            "${encodeFolder}/${fileToEncodeSmall}", "${decodeFolder}/${fileToEncodeSmall}",
+        encoder.decode("${encodeFolder}/${fileToEncodeSmall}", "${decodeFolder}/${fileToEncodeSmall}",
             applyByteMapping = true,
-            applyBurrowsWheelerTransformation = true
-        )
+            applyBurrowsWheelerTransformation = true)
     }
 
-
+/*
     @Test
     @Order(3)
     fun encodeFileSmall2() {
-        encoder.encode(
-            "data/${fileToEncodeSmall2}", "${encodeFolder}/${fileToEncodeSmall2}",
-            applyByteMapping = true,
-            applyBurrowsWheelerTransformation = true
-        )
+        encoder.encode("data/${fileToEncodeSmall2}", "${encodeFolder}/${fileToEncodeSmall2}")
     }
 
 
     @Test
     @Order(4)
     fun encodeFile() {
-        encoder.encode(
-            "data/${fileToEncode}", "${encodeFolder}/${fileToEncode}",
-            applyByteMapping = true,
-            applyBurrowsWheelerTransformation = true
-        )
+        encoder.encode("data/${fileToEncode}", "${encodeFolder}/${fileToEncode}")
     }
 
     @Test
@@ -109,24 +96,18 @@ class MixedEncoderTest {
     }
 
 
+
+
     @Test
     @Order(8)
     fun decodeFileSmall2() {
-        encoder.decode(
-            "${encodeFolder}/${fileToEncodeSmall2}", "${decodeFolder}/${fileToEncodeSmall2}",
-            applyByteMapping = true,
-            applyBurrowsWheelerTransformation = true
-        )
+        encoder.decode("${encodeFolder}/${fileToEncodeSmall2}", "${decodeFolder}/${fileToEncodeSmall2}")
     }
 
     @Test
     @Order(8)
     fun decodeFile() {
-        encoder.decode(
-            "${encodeFolder}/${fileToEncode}", "${decodeFolder}/${fileToEncode}",
-            applyByteMapping = true,
-            applyBurrowsWheelerTransformation = true
-        )
+        encoder.decode("${encodeFolder}/${fileToEncode}", "${decodeFolder}/${fileToEncode}")
     }
-
+*/
 }
\ No newline at end of file
